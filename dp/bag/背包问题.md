# 背包问题所有分类
![img.png](../img/img_2112091555.png)


# 题目汇总
## leetcode上的背包问题

力扣」上的 0-1 背包问题: 

「力扣」第 416 题: 分割等和子集（中等）；
「力扣」第 474 题: 一和零（中等）；
「力扣」第 494 题: 目标和（中等）；
「力扣」第 879 题: 盈利计划（困难）；
「力扣」上的 完全背包问题: 

「力扣」第 322 题: 零钱兑换（中等）；
「力扣」第 518 题: 零钱兑换 II（中等）；
「力扣」第 1449 题: 数位成本和为目标值的最大数字（困难）. 
这里要注意鉴别: 「力扣」第 377 题, 不是「完全背包」问题. 

## LintCode

[背包问题](https://www.lintcode.com/problem-tag/400/)

# 01背包

## 二维dp

有N件物品和一个最多能背重量为W 的背包. 第i件物品的重量是weight[i], 得到的价值是value[i] . **每件物品只能用一次**, 求解将哪些物品装入背包里物品价值总和最大. 

题目例子: 背包最大重量为4. 物品为: 

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

问背包能背的物品最大价值是多少？

---

暴力解法:

每一件物品其实只有两个状态, 取或者不取, 所以可以使用回溯法搜索出所有的情况, 那么时间复杂度就是O(2^n), 这里的n表示物品数量. 

**所以暴力的解法是指数级别的时间复杂度. 进而才需要动态规划的解法来进行优化！**

---

依然动规五部曲分析一波. 

1. 确定dp数组以及下标的含义

使用二维数组, **`dp[i][j]`: 表示从下标为[0-i]的物品里任意取, 放进容量为j的背包, 价值总和最大是多少**. 

下面这个图：

![动态规划-背包问题1](img/背包问题/20210110103003361.png)

**要时刻记着这个dp数组的含义, 下面的一些步骤都围绕这dp数组的含义进行的**

2. 确定递推公式

`dp[i][j]`的含义：从下标为[0-i]的物品里任意取, 放进容量为j的背包, 价值总和最大是多少. 

那么可以有两个方向推出来`dp[i][j]`, 

* **不放物品i**：由`dp[i - 1][j]`推出, 即背包容量为j, 里面不放物品i的最大价值, 此时`dp[i][j]`就是`dp[i - 1][j]`. (其实就是当物品i的重量大于背包j的重量时, 物品i无法放进背包中, 所以被背包内的价值依然和前面相同. )
* **放物品i**：由`dp[i - 1][j - weight[i]]`推出, `dp[i - 1][j - weight[i]]`为背包容量为j - weight[i]的时候不放物品i的最大价值, 那么`dp[i - 1][j - weight[i]] + value[i]` （物品i的价值）, 就是背包放物品i得到的最大价值

所以递归公式： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`

3. dp数组如何初始化

**关于初始化, 一定要和dp数组的定义吻合, 否则到递推公式的时候就会越来越乱**. 

首先从dp[i][j]的定义出发, 如果背包容量j为0的话, 即dp[i][0], 无论是选取哪些物品, 背包价值总和一定为0. 如图：

![动态规划-背包问题2](img/背包问题/2021011010304192.png)

在看其他情况. 

状态转移方程 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);` 可以看出i 是由 i-1 推导出来, 那么i为0的时候就一定要初始化. 

`dp[0][j]`, 即：i为0, 存放编号0的物品的时候, 各个容量的背包所能存放的最大价值. 

那么很明显当 j < weight[0]的时候, `dp[0][j] `应该是 0, 因为背包容量比编号0的物品重量还小. 

当j >= weight[0]时, `dp[0][j]`应该是value[0], 因为背包容量放足够放编号0物品. 

代码初始化如下：

``` 
for (int j = 0 ; j < weight[0]; j++) {  // 当然这一步, 如果把dp数组预先初始化为0了, 这一步就可以省略, 但很多同学应该没有想清楚这一点. 
    dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagWeight; j++) {
    dp[0][j] = value[0];
}
```


此时dp数组初始化情况如图所示：

![动态规划-背包问题7](img/背包问题/20210110103109140.png)

`dp[0][j]` 和 `dp[i][0]` 都已经初始化了, 那么其他下标应该初始化多少呢？

其实从递归公式： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); `可以看出`dp[i][j]`是又左上方数值推导出来了, 那么 其他下标初始为什么数值都可以, 因为都会被覆盖. 

**初始-1, 初始-2, 初始100, 都可以！**

但只不过一开始就统一把dp数组统一初始为0, 更方便一些. 

如图：

![动态规划-背包问题10](img/背包问题/动态规划-背包问题10.jpg)

最后初始化代码如下：

```
// 初始化 dp
vector<vector<int>> dp(weight.size(), vector<int>(bagWeight + 1, 0));
for (int j = weight[0]; j <= bagWeight; j++) {
    dp[0][j] = value[0];
}

```

**费了这么大的功夫, 才把如何初始化讲清楚, 相信不少同学平时初始化dp数组是凭感觉来的, 但有时候感觉是不靠谱的**. 

4. 确定遍历顺序


在如下图中, 可以看出, 有两个遍历的维度：物品与背包重量

![动态规划-背包问题3](img/背包问题/2021011010314055.png)

那么问题来了, **先遍历 物品还是先遍历背包重量呢？**

**其实都可以！！ 但是先遍历物品更好理解**. 

那么我先给出先遍历物品, 然后遍历背包重量的代码. 

```
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; 
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```

**先遍历背包, 再遍历物品, 也是可以的！（注意我这里使用的二维dp数组）**

例如这样：

```
// weight数组的大小 就是物品个数
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

为什么也是可以的呢？

**要理解递归的本质和递推的方向**. 

`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);` 递归公式中可以看出`dp[i][j]`是靠`dp[i-1][j]`和`dp[i - 1][j - weight[i]]`推导出来的. 

`dp[i-1][j]`和`dp[i - 1][j - weight[i]]`都在`dp[i][j]`的左上角方向（包括正上方向）, 那么先遍历物品, 再遍历背包的过程如图所示：

![动态规划-背包问题5](img/背包问题/202101101032124.png)

再来看看先遍历背包, 再遍历物品呢, 如图：

![动态规划-背包问题6](img/背包问题/20210110103244701.png)

**大家可以看出, 虽然两个for循环遍历的次序不同, 但是dp[i][j]所需要的数据就是左上角, 根本不影响dp[i][j]公式的推导！**

但先遍历物品再遍历背包这个顺序更好理解. 

**其实背包问题里, 两个for循环的先后循序是非常有讲究的, 理解遍历顺序其实比理解推导公式难多了**. 

5. 举例推导dp数组

来看一下对应的dp数组的数值, 如图：

![动态规划-背包问题4](img/背包问题/20210118163425129.jpg)

最终结果就是`dp[2][4]`. 

建议大家此时自己在纸上推导一遍, 看看dp数组里每一个数值是不是这样的. 

**做动态规划的题目, 最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下, 然后在动手写代码！**

很多同学做dp题目, 遇到各种问题, 然后凭感觉东改改西改改, 怎么改都不对, 或者稀里糊涂就改过了. 

主要就是自己没有动手推导一下dp数组的演变过程, 如果推导明白了, 代码写出来就算有问题, 只要把dp数组打印出来, 对比一下和自己推导的有什么差异, 很快就可以发现问题了. 

























Java, dp二维数组的01背包问题: 

```java
package leetcode.dp.bag;

/**
 * https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.md
 * <p>
 * dp[i][j]的含义：
 * 从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
 * <p>
 * !!! 这里的dp和下文的dp概念不一样
 * <p>
 * 那么可以有两个方向推出来dp[i][v]
 * <p>
 * 1. 不放物品i：由dp[i - 1][v]推出，即背包容量为v，里面不放物品i的最大价值，
 * 此时dp[i][j]就是dp[i - 1][v]。
 * (其实就是当物品i的重量大于背包v的重量时, 物品i无法放进背包中, 所以被背包内的价值依然和前面相同。)
 * <p>
 * <p>
 * 2. 放物品i：由dp[i - 1][v - weight[i]]推出，
 * dp[i - 1][v - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，
 * 那么dp[i - 1][v - weight[i]] + value[i](物品i的价值), 就是背包放物品i得到的最大价值
 */
public class Bag01Test {

    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagSize = 4;
        testWeightBagProblem(weight.length, weight, value, bagSize);
    }

    public static void testWeightBagProblem(int n, int[] weight, int[] value, int bagSize) {
        // dp[i][v]: dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值
        // 前i个物品: [0,i-1]
        //
        // pat算法笔记中: 前i件物品(1<=i<=n, 0<=v<=V)恰好装入容量为v的背包中所能获得的最大价值

        // 前n个数, [0,n], 开的数组是n+1
        // 这是前缀形题目的注意点
        int[][] dp = new int[n + 1][bagSize + 1];

        // 初始化：背包容量为0时，能获得的价值都为0
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }

        // 遍历顺序：先遍历物品，再遍历背包容量
        // 遍历物品, n为物品个数
        for (int i = 1; i <= n; i++) {
            // 遍历背包容量
            for (int v = 1; v <= bagSize; v++) {
                // 其实就是当物品i的重量大于背包v的重量时,
                // 物品i无法放进背包中, 所以被背包内的价值依然和前面相同
                // 第i个数的下标是i-1
                if (weight[i - 1] > v) {
                    dp[i][v] = dp[i - 1][v];
                } else {
                    // 物品i可以放入背包,重量小于背包容量, 看要不要放入
                    dp[i][v] = Math.max(
                        dp[i - 1][v],
                        dp[i - 1][v - weight[i - 1]] + value[i - 1]);
                }
            }
        }
        //打印dp数组
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= bagSize; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.print("\n");
        }
    }
}
```















## 滚动数组, 一维dp







```java
package leetcode.dp.bag;

import java.util.Arrays;

/**
 * 一维dp数组
 * 空间复杂度 O(V)
 */
public class Bag01Test_3 {
    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int V = 4;
        testWeightBagProblem3(weight.length, weight, value, V);
    }

    /**
     * dp[j]表示背包容量为j时，能获得的最大价值
     */
    private static void testWeightBagProblem3(int n, int[] weight, int[] value, int V) {
        // 定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值
        int[] dp = new int[V + 1];

        //遍历顺序：先遍历物品，再遍历背包容量
        // [0, n), weight和value就是第i个
        for (int i = 0; i < n; i++) {
            for (int v = V; v >= weight[i]; v--) {
                // 此时dp[j]有两个选择，
                // 1.取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，
                // 2.取dp[j - weight[i]] + value[i]，即放物品i，
                dp[v] = Math.max(dp[v], dp[v - weight[i]] + value[i]);
            }

            // 打印dp数组
            System.out.println(i + ":" + Arrays.toString(dp));
        }
    }
}
```





## 例题















# 完全背包















# 多重背包

一般考察01背包和完全背包, 但是笔试也开始有多重背包了












# 题目
## 外卖券
你有一张满X元减10元的满减券和每个菜品的价格（整数）, 每个菜最多只买一份. 问最少买多少钱可以用得上这张外卖券？  
挑选若干数之和>=X且和最小 = 挑选出一些“不加入购物车”的菜品, 尽可能填满一个SUM-X的背包
又变成了01背包类目

## 石头碰撞
给出N个石头及其大小数组, 每次选2个石头进行碰撞, 大小分别为×,y 
碰撞之后会变成一个石头, 大小变为|x-y|
直到石头个数<2为止, 问最后剩下来的石头最小是多少？



















# Ref

1. 作者: liweiwei1419
   链接: https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/
   来源: 力扣（LeetCode）
   著作权归作者所有. 商业转载请联系作者获得授权, 非商业转载请注明出处. 

2. [背包理论基础01背包-1.](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.md#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%8401%E8%83%8C%E5%8C%85)

3. [背包理论基础01背包-2.md](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.md)

4. [背包问题理论基础完全背包.md](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.md)
5. [背包问题理论基础多重背包.md](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.md)

6. [背包总结篇.md](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.md)































