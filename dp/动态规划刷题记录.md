# 爬楼梯 & FibonacciNumber
## FibonacciNumber_509 & ClimbingStairs_70
Fibonacci直接告诉递推公式: f(n) = f(n-1) + f(n-2)  

爬楼梯问题也是类似的, 因为每次都可以爬两个台阶或者一个台阶

```
dp, 每次你可以爬 1 或 2 个台阶
dp[n]有多少中爬法
dp[n]就是dp[n-1]爬一个台阶, dp[n-2]爬两个台阶, 这两个爬法加起来
f(n) = f(n-1) + f(n-2)
```

```java
public int climbStairs(int n) {
    int[] step = new int[1000];
    step[0] = 0;
    step[1] = 1;
    step[2] = 2;
    for (int i = 3; i <= n; i++) {

        step[i] = step[i - 1] + step[i - 2];

    }
    return step[n];
}
```

实际上发现, 他只与前两次状态有关, pre1, pre2, cur. 降低空间复杂度

```java
public int climbStairs(int n) {
    if (n == 0 || n == 1 || n == 2) {
        return n;
    }
    int result = 0;
    int pre1 = 1;
    int pre2 = 2;
    for (int i = 3; i <= n; i++) {
        result = pre1 + pre2;
        pre1 = pre2;
        pre2 = result;
    }
    return result;
}
```



## NthTribonacciNumber_1137

```
Tn+3 = Tn + Tn+1 + Tn+2
```

类似普通的Fibonacci, 无非就是每一个dp状态与前三个数字有关

```java
public int tribonacci(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    if (n == 2) {
        return 1;
    }

    int result = 0;
    int pre1 = 0;
    int pre2 = 1;
    int pre3 = 1;

    for (int i = 3; i <= n; i++) {
        result = pre1 + pre2 + pre3;
        pre1 = pre2;
        pre2 = pre3;
        pre3 = result;
    }

    return result;
}
```









## 最小花费爬楼梯:MinCostClimbingStairs_746

```
给你一个整数数组 cost ,其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用.
一旦你支付此费用,即可选择向上爬一个或者两个台阶.
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯.
请你计算并返回达到楼梯顶部的最低花费.
```

```
dp[i]: 爬到第i个台阶的最小花费
dp[i]有两种可能:
1. 第i-1号台阶, 支付了cost[i-1]然后爬1步上来的
2. 第i-2号台阶, 支付了cost[i-2]然后爬2步上来的
看哪个花费最小.Math.min()
n=3, 那么就要爬到第3号台阶, 0,1,2,3
```

```java
public int minCostClimbingStairs(int[] cost) {
    int n = cost.length;
    if (n == 0) {
        return 0;
    }
    // 可以从0号台阶, 或者1号台阶开始爬, 那么就不需要任何花费
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 0;
    for (int i = 2; i <= n; i++) {
        dp[i] = Math.min(
            dp[i - 1] + cost[i - 1],
            dp[i - 2] + cost[i - 2]);
    }
    return dp[n];
}
```











# 打家劫舍问题
## HouseRobber1_198

```java
/**
     * dp[i]: 偷到第i家的时候, 能偷到的最多的前
     * dp[0]: 第0家, 那么必偷
     * dp[1]: 就看偷不偷0, 如果偷0, 那么1就不偷, 如果不偷0, 就偷1
     * 所以要看dp[0]和nums[1]的大小
     * 
     * 所以dp[i]取决于dp[i-1], 偷不偷第i-1户人家,
     * 如果偷i-1th: 那就偷不了nums[i], 钱就是dp[i-1]
     * 如果不偷i-1th: 那就要偷nums[i], 钱就是dp[i-2] + nums[i]
     * 看哪个大
     */
static class Solution {
    public int rob(int[] nums) {
        int n = nums.length;

        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }

        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }
}
```

## HouseRobber2_213

和1的不同点在于是环, 意味着

1. 如果你选择了第一个房屋偷窃,就一定不能选择最后一间了

2. 如果你没有选择第一个房屋偷窃,那么你就能偷窃最后一间房屋.

所以这里转换成两个区间[0, n-2]和[1, n-1], 分别是rob1的思路, 然后取大的那个

```java
/**
     * 成了一个环, 那么如果投了第n-1个, 就不能偷第0个
     * 如果没有偷第0个就可以偷第n-1个
     * 
     * 所以这里可以把理解成, 我偷两次, 只不过范围不一样, 然后投的策略和1是一样的
     * 
     * 例如: 6户人家, 两种偷法 , 取最大的那个
     * 0 1 2 3 4 5
     * 0 1 2 3 4
     * 1 2 3 4 5
     */
static class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }
        if (n == 2) {
            return Math.max(nums[0], nums[1]);
        }

        int[] path1 = new int[n - 1];
        System.arraycopy(nums, 0, path1, 0, n - 1);

        int[] path2 = new int[n - 1];
        System.arraycopy(nums, 1, path2, 0, n - 1);

        return Math.max(rob1(path1), rob1(path2));
    }

    private int rob1(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(
                dp[i - 1],
                dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }
}
```

## DeleteAndEarn_740

这道题目其实就是打家劫舍, 自己想的时候咩有关联起来

每次操作中,选择任意一个 nums[i] ,删除它并获得 nums[i] 的点数.之后,你必须删除**所有**等于 nums[i] - 1 和 nums[i] + 1 的元素.

重点在于上面说的"所有", 所以例子:[2,2,3,3,3,4]:

选3, 删除所有的2(有两个), 删除4. nums=[3,3]

选3, 没有好删除的数字, nums=[3]

选3.

最后result就是3+3+3 = 9;

---

所以数组nums = [2,2,3,3,3,4]可以转换为打家劫舍的形式:

每个位置都是对应的数字个数, 也就是资产, 

count=[0, 0, 2, 3, 1]. 0个0, 0个1, 2个2, 3个3, 1个4

count数组记录, nums数组中数字出现的个数

count[m] = n, 数字m出现了n次

---

状态方程的思考过程: 

dp[i]: 到了第i个位置上, result的最大值, (到第i个位置, 删除数字的和最大)

第i个位置的数字可以删除也可以不删除, 依据是: 两种前结果之上进行选择的:

1. 如果你不删除当前位置的数字,那么你得到就是前一个数字的位置的最优结果.
2. 如果你觉得当前的位置数字i需要被删,那么你就会得到i - 2位置的那个最优结果加上当前位置的数字乘以个数.

dp[i] = max(dp[i-1], dp[i-2] + count[i] * i)

---

初始化

i-2, 所以初始化0,1
dp[0] : 0乘以任何数都是0, 初始化就是0
dp[1] = count[1] * 1;

---

最终

```java
/**
     * ount=[0, 0, 2, 3, 1]. 0个0, 0个1, 2个2, 3个3, 1个4
     * 
     * 状态方程的思考过程:
     * 
     * dp[i]: 到了第i个位置上, result的最大值, (到第i个位置, 删除数字的和最大)
     * 
     * 第i个位置的数字可以删除也可以不删除, 依据是: 两种前结果之上进行选择的:
     * 
     * 1. 如果你不删除当前位置的数字,那么你得到就是前一个数字的位置的最优结果.
     * 2. 如果你觉得当前的位置数字i需要被删,那么你就会得到i - 2位置的那个最优结果加上当前位置的数字乘以个数.
     * 
     * dp[i] = max(dp[i-1], dp[i-2] + count[i] * i)
     */
static class Solution {
    public int deleteAndEarn(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        int max = -1;
        for (int num : nums) {
            if (num > max) {
                max = num;
            }
        }

        // 数字出现的次数
        // count[m] = n, 数字m出现了n次
        int[] count = new int[max + 1];

        // count数组记录, nums数组中数字出现的个数
        for (int num : nums) {
            count[num]++;
        }

        // dp: 到数字i, result的最大值, 看数字i取不取, 取与不取有两种情况
        int[] dp = new int[max + 1];
        // 数字0, 没用
        dp[0] = 0;
        dp[1] = count[1] * 1;
        for (int i = 2; i <= max; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + count[i] * i);
        }
        return dp[max];
    }
}
```









## HouseRobber3_337










# 背包问题

## 背包问题所有分类
![img.png](/img/img_2112091555.png)


## leetcode上的背包问题
力扣」上的 0-1 背包问题：

「力扣」第 416 题：分割等和子集（中等）；
「力扣」第 474 题：一和零（中等）；
「力扣」第 494 题：目标和（中等）；
「力扣」第 879 题：盈利计划（困难）；
「力扣」上的 完全背包问题：

「力扣」第 322 题：零钱兑换（中等）；
「力扣」第 518 题：零钱兑换 II（中等）；
「力扣」第 1449 题：数位成本和为目标值的最大数字（困难）。
这里要注意鉴别：「力扣」第 377 题，不是「完全背包」问题。


## 题目
### 外卖券
你有一张满X元减10元的满减券和每个菜品的价格（整数），每个菜最多只买一份。问最少买多少钱可以用得上这张外卖券？  
挑选若干数之和>=X且和最小 = 挑选出一些“不加入购物车”的菜品, 尽可能填满一个SUM-X的背包
又变成了01背包类目

### 石头碰撞
给出N个石头及其大小数组, 每次选2个石头进行碰撞，大小分别为×,y 
碰撞之后会变成一个石头，大小变为|x-y|
直到石头个数<2为止, 问最后剩下来的石头最小是多少？























# 股票售卖最佳时机
121, 122, 123, 188, 309, 714

## 通用题解

[通用题解1](https://labuladong.gitee.io/algo/3/26/95/)

[通用题解2](https://leetcode-cn.com/circle/article/qiAgHn/)

### 穷举框架

**每天都有三种「选择」**:买入、卖出、无操作,我们用 `buy`, `sell`, `rest` 表示这三种选择.

但问题是,并不是每天都可以任意选择这三种选择的,因为 `sell` 必须在 `buy` 之后,`buy` 必须在 `sell` 之后.那么 `rest` 操作还应该分两种状态,一种是 `buy` 之后的 `rest`（持有了股票）,一种是 `sell` 之后的 `rest`（没有持有股票）.而且别忘了,我们还有交易次数 `k` 的限制,就是说你 `buy` 还只能在 `k > 0` 的前提下操作.

```
dp[i][k][0 or 1]
0 <= i <= n - 1, 1 <= k <= K
n 为天数,大 K 为交易数的上限,0 和 1 代表是否持有股票.
for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
```

而且我们可以用自然语言描述出每一个状态的含义,比如说 `dp[3][2][1]` 的含义就是:今天是第三天,我现在手上持有着股票,至今最多进行 2 次交易.再比如 `dp[2][3][0]` 的含义:今天是第二天,我现在手上没有持有股票,至今最多进行 3 次交易.

我们想求的最终答案是 `dp[n - 1][K][0]`,即最后一天,最多允许 `K` 次交易,最多获得多少利润.

为什么不是 `dp[n - 1][K][1]`？因为 `dp[n - 1][K][1]` 代表到最后一天手上还持有股票,`dp[n - 1][K][0]` 表示最后一天手上的股票已经卖出去了,很显然后者得到的利润一定大于前者

### 状态转移

```
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max( 今天选择 rest,        今天选择 sell       )
```

解释: 今天我没有持有股票, 从昨天推过来有两种可能, 取最大值

1. 我昨天就没有持有, 且截至昨天最大交易次数限制为 `k`; 然后我今天选择 `rest`, 所以我今天还是没有持有, 最大交易次数限制依然为 `k`.

2. 我昨天持有股票, 且截至昨天最大交易次数限制为 `k`; 但是今天我 `sell` 了, 所以我今天没有持有股票了, 最大交易次数限制依然为 `k`.

---

```
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max( 今天选择 rest,         今天选择 buy         )
```

1. 我昨天就持有着股票, 且截至昨天最大交易次数限制为 `k`; 然后今天选择 `rest`, 所以我今天还持有着股票, 最大交易次数限制依然为 `k`. 

2. 我昨天本没有持有, 且截至昨天最大交易次数限制为 `k - 1`; 但今天我选择 `buy`, 所以今天我就持有股票了, 最大交易次数限制为 `k`. 

> 这里着重提醒一下，时刻牢记「状态」的定义，`k` 的定义并不是「已进行的交易次数」，而是「最大交易次数的上限限制」。如果确定今天进行一次交易，且要保证截至今天最大交易次数上限为 `k`，那么昨天的最大交易次数上限必须是 `k - 1`。

如果 `buy`，就要从利润中减去 `prices[i]`，如果 `sell`，就要给利润增加 `prices[i]`。今天的最大利润就是这两种可能选择中较大的那个。

注意 `k` 的限制，在选择 `buy` 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 `k` 应该减小 1。

> 修正：以前我以为在 `sell` 的时候给 `k` 减小 1 和在 `buy` 的时候给 `k` 减小 1 是等效的，但细心的读者向我提出质疑，经过深入思考我发现前者确实是错误的，因为交易是从 `buy` 开始，如果 `buy` 的选择不改变交易次数 `k` 的约束，会出现交易次数超出限制的的错误。

###  base case

```
dp[-1][...][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。

dp[-1][...][1] = -infinity
解释：还没开始的时候，是不可能持有股票的。
因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。

dp[...][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。

dp[...][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的。
因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
```

---

总结: 

```
base case：
dp[-1][...][0] = dp[...][0][0] = 0
dp[-1][...][1] = dp[...][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

## 题目与解法

### 买卖股票的最佳时机_121

只交易一次, 所以k=1. 对上面的式子做一些调整:

```
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) 
            = max(dp[i-1][1][1], -prices[i])
解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。

现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
可以进行进一步化简去掉所有 k：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
```

i=0的时候, base case

```
dp[i][0] = 0;
// 根据状态转移方程可得：
//   dp[i][0] 
// = max(dp[-1][0], dp[-1][1] + prices[i])
// = max(0, -infinity + prices[i]) = 0

dp[i][1] = -prices[i];
// 根据状态转移方程可得：
//   dp[i][1] 
// = max(dp[-1][1], dp[-1][0] - prices[i])
// = max(-infinity, 0 - prices[i]) 
// = -prices[i]
```

同时可以注意到, 这里状态只与之前的i-1的状态有关, 所以实际上不需要用一整个数组来进行存储, 可以只使用两个数字来记录前两个状态. 解法如下:

```java
public class BuyAndSellStock_121_2 {
    public static void main(String[] args) {
        int[] prices = {7, 1, 5, 3, 6, 4};
        System.out.println(new Solution().maxProfit(prices));

    }
    /**
     * solution2中可以看到状态只与前一天有关, 所以不需要数组, 只需要保存前一天数据即可
     *
     * # 三维
     * dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]);
     * dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]);
     *             = max(dp[i-1][1][1], -prices[i]);
     *
     * # 二维
     * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
     * dp[i][1] = max(dp[i-1][1], -prices[i]);
     *
     * dp[0][0] = 0
     * dp[0][1] = -prices[i];
     *
     * # 只与前一个状态有关
     */
    static class Solution {
        public int maxProfit(int[] prices) {
            int n = prices.length;
            int dp_pre_0 = 0;
            int dp_pre_1 = -prices[0];

            int dp_cur_0 = 0;
            int dp_cur_1 = 0;

            for (int i = 1; i < n; i++) {
                dp_cur_0 = Math.max(dp_pre_0, dp_pre_1 + prices[i]);
                dp_cur_1 = Math.max(dp_pre_1, -prices[i]);

                dp_pre_0 = dp_cur_0;
                dp_pre_1 = dp_cur_1;
            }

            return dp_cur_0;
        }
    }

    /**
     * 按照笔记中的通用方法
     * 
     * dp[i][k][0 or 1]: 第i天, 最多交易次数为k,0: 没有持有股票, 1: 持有股票.
     * 最多获得多少利润。
     * 
     * 这里的因为只bug sell一次, 所以k = 1
     * 务必在buy的时候, k--;
     * 
     * # 状态转移:
     * 今天未持有股票:
     * dp[i][1][0]: max(dp[i-1][1][0], dp[i-1][1][1] + price[i])
     * 1. 昨天未持有股票, 今天啥都没干. rest
     * 2. 昨天持有股票, 今天卖了股票. sell
     * 
     * 今天持有股票:
     * dp[i][1][1]: max(dp[i-1][1][1], dp[i-1][0][0] - price[i])
     * 因为dp[i-1][0][0]: 最大交易次数为0, 并且不持有股票, 所以 = 0
     * dp[i][1][1] = max(dp[i-1][1][1], -price[i])
     * 
     * 1. 昨天也持有股票, 今天rest
     * 2. 昨天未持有股票, 今天buy
     * 
     * 
     * dp[i][1][0]: max(dp[i-1][1][0], dp[i-1][1][0] + price[i])
     * dp[i][1][1] = max(dp[i-1][1][1], -price[i])
     * 因为这里的k的次数固定是1, 所以这一维的状态可以不用管. 3维 -> 2维
     * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + price[i])
     * dp[i][1] = max(dp[i-1][1], -price[i])
     * 
     * 
     * # base case:
     * i-1, 所以i=0的情况
     * dp[0][0] = max(dp[-1][0], dp[-1][1] + price[0])
     * = max(0, -inf) = 0
     * 因为dp[-1][1], 在-1天的时候不可能持有股票
     * 
     * 
     * dp[0][1] = max(dp[-1][1], -price[0])
     * = -price[0]
     */
    static class Solution2 {
        public int maxProfit(int[] prices) {
            int n = prices.length;
            int[][] dp = new int[n][2];
            dp[0][0] = 0;
            dp[0][1] = -prices[0];

            for (int i = 1; i < n; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
            }

            return dp[n - 1][0];
        }
    }
    /**
     * 暴力, 超时
     * 找出数组中两个数字之间的最大差值
     * 双for
     */
    static class Solution1 {
        public int maxProfit(int[] prices) {
            int max = 0;

            for (int i = 0; i < prices.length; i++) {
                for (int j = i + 1; j < prices.length; j++) {
                    int profit = prices[j] - prices[i];
                    if (profit > max) {
                        max = profit;
                    }
                }
            }
            return max;
        }
    }
}
```

### 买卖股票的最佳时机2_122

你可以尽可能地完成更多的交易(多次买卖一支股票), 所以k是+inf, 所以k和k-1就一样了

状态转移方程:

```
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]);
```

也就是说, 和k无关了, 所以取消k的维度

```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
```

base case:

```
dp[0][0] = max(dp[-1][0], dp[-1][1] + prices[0]) = 0
dp[0][1] = max(dp[-1][1], dp[-1][0] - prices[0]) = -prices[0]
```

同时和1一样观察看实际只与前一天的状态有关, 不需要用数组存储

```java
public class BuyAndSellStock2_122 {
    public static void main(String[] args) {
        int[] prices = {7, 1, 5, 3, 6, 4};
        System.out.println(new Solution().maxProfit(prices));
    }
    static class Solution {
        public int maxProfit(int[] prices) {
            int n = prices.length;

            // base case:
            int dp_pre_0 = 0;
            int dp_pre_1 = -prices[0];

            int dp_cur_0 = 0;
            int dp_cur_1 = 0;

            for (int i = 1; i < n; i++) {
                dp_cur_0 = Math.max(dp_pre_0, dp_pre_1 + prices[i]);
                dp_cur_1 = Math.max(dp_pre_1, dp_pre_0 - prices[i]);

                dp_pre_0 = dp_cur_0;
                dp_pre_1 = dp_cur_1;
            }

            return dp_cur_0;
        }
    }
    /**
     * 你可以尽可能地完成更多的交易(多次买卖一支股票), 所以k是+inf, 所以k和k-1就一样了
     * 
     * 状态转移方程:
     * dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
     * dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
     * = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]);
     * 
     * 也就是说, 和k无关了, 所以取消k的维度
     * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
     * dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
     * 
     * 
     * base case:
     * dp[0][0] = max(dp[-1][0], dp[-1][1] + prices[0]) = 0
     * 
     * dp[0][1] = max(dp[-1][1], dp[-1][0] - prices[0]) = -prices[0]
     */
    static class Solution1 {
        public int maxProfit(int[] prices) {
            int n = prices.length;

            int[][] dp = new int[n][2];
            dp[0][0] = 0;
            dp[0][1] = -prices[0];

            for (int i = 1; i < n; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            }
            return dp[n - 1][0];
        }
    }
}
```

### 买卖股票的最佳时机含手续费_714

你可以无限次地完成交易, 但是你每笔交易都需要付手续费

k=inf, 交易的时候减去fee -> buy的时候-fee和sell的时候-fee

具体的推导见代码注释:

```java
/**
 * 对股票买卖2的扩展
 * 无限次地完成交易, 但是你每笔交易都需要付手续费
 * k=inf, 交易加上fee
 */
public class BuyAndSellStockWithTransactionFee_714 {
    public static void main(String[] args) {

        int[] prices = new int[]{1, 3, 2, 8, 4, 9};
        int fee = 2;
        System.out.println(new Solution().maxProfit(prices, fee));

    }
    /**
     * # 状态转移1
     * ## buy的时候交手续费
     * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
     * dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
     * 
     * ## sell时缴费的base case
     * dp[0][0] = max(dp[-1][0], dp[-1][1] + prices[0])
     * = max(0, -inf) = 0
     * 
     * dp[0][1] = max(dp[-1][1], dp[-1][0] - prices[0] - fee)
     * = max(-inf, -price[0] - fee) = -price[0] - fee
     */
    static class Solution {
        public int maxProfit(int[] prices, int fee) {
            int[][] dp = new int[prices.length][2];

            dp[0][0] = 0;
            dp[0][1] = -prices[0] - fee;

            for (int i = 1; i < prices.length; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
            }

            return dp[prices.length - 1][0];
        }
    }

    /**
     * sell的时候交手续费
     * dp[i][k][0]
     * 
     * dp[i][k][1]
     * 
     * 
     * 因为有手续费, 所以在sell或者buy的时候减去手续费
     * k是inf, 不再考虑
     * 
     * # 状态转移1
     * ## sell的时候交手续费
     * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)
     * dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
     * 
     * ## sell时缴费的base case
     * dp[0][0] = max(dp[-1][0], dp[-1][1] + prices[0] - fee)
     * = max(0, -inf) = 0
     * 
     * dp[0][1] = max(dp[-1][1], dp[-1][0] - prices[0])
     * = max(-inf, -price[0]) = -price[0]
     */
    static class Solution1 {
        public int maxProfit(int[] prices, int fee) {
            int[][] dp = new int[prices.length][2];

            dp[0][0] = 0;
            dp[0][1] = -prices[0];

            for (int i = 1; i < prices.length; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            }
            return dp[prices.length - 1][0];
        }
    }

}
```

> (虽然没有遇到): 
>
> 如果直接把 `fee` 放在第一个式子里减，会有测试用例无法通过，错误原因是整型溢出而不是思路问题。一种解决方案是把代码中的 `int` 类型都改成 `long` 类型，避免 `int` 的整型溢出。

### 最佳买卖股票时机含冷冻期_309

你可以尽可能地完成更多的交易
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

```
# 状态方程
dp[i][k][1 or 0]

k = +inf

dp[i][0]
dp[i][1]

影响的就是当要buy的时候, i-2

dp[i][0]不受影响, 因为是sell
dp[i][1]受影响, 因为是buy

dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])

dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])

# base case:
初始化的时候也要修改
dp[0][0] = max(dp[-1][0], dp[-1][1] + prices[0])
= max(0, -inf+prices[0])
= 0
dp[0][1] = max(dp[i-1][1], dp[i-2][0] - prices[0])
= max(dp[-1][1], dp[-2][0] - prices[0])
= max(-inf, -prices[0])
= -prices[0]
---
dp[1][0] = max(dp[i-1][0], dp[i-1][1] + prices[1])
= max(dp[0][0], dp[0][1] + prices[1])
= max(0, -prices[0] + prices[1])

dp[1][1] = max(dp[i-1][1], dp[i-2][0] - prices[1])
= max(dp[0][1], dp[-1][0] - prices[1])
= max(-prices[0], -prices[1])
```




```java
/**
 * 你可以尽可能地完成更多的交易
 * 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
 * 
 * # 状态方程
 * dp[i][k][1 or 0]
 * 
 * k = +inf
 * 
 * dp[i][0]
 * dp[i][1]
 * 
 * 影响的就是当要buy的时候, i-2
 * 
 * dp[i][0]不受影响, 因为是sell
 * dp[i][1]受影响, 因为是buy
 * 
 * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
 * 
 * dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
 * 
 * 
 * # base case:
 * 初始化的时候也要修改
 * dp[0][0] = max(dp[-1][0], dp[-1][1] + prices[0])
 * = max(0, -inf+prices[0])
 * = 0
 * dp[0][1] = max(dp[i-1][1], dp[i-2][0] - prices[0])
 * = max(dp[-1][1], dp[-2][0] - prices[0])
 * = max(-inf, -prices[0])
 * = -prices[0]
 * ---
 * dp[1][0] = max(dp[i-1][0], dp[i-1][1] + prices[1])
 * = max(dp[0][0], dp[0][1] + prices[1])
 * = max(0, -prices[0] + prices[1])
 * 
 * dp[1][1] = max(dp[i-1][1], dp[i-2][0] - prices[1])
 * = max(dp[0][1], dp[-1][0] - prices[1])
 * = max(-prices[0], -prices[1])
 */
public class BuyAndSellStockWithCoolDown_309 {
    public static void main(String[] args) {

        int[] prices = new int[]{1, 2, 3, 0, 2};

        System.out.println(new Solution().maxProfit(prices));
    }

    static class Solution {
        public int maxProfit(int[] prices) {
            if (prices.length == 1) {
                return 0;
            }
            int[][] dp = new int[prices.length][2];
            dp[0][0] = 0;
            dp[0][1] = -prices[0];

            dp[1][0] = Math.max(0, -prices[0] + prices[1]);
            dp[1][1] = Math.max(-prices[0], -prices[1]);


            for (int i = 2; i < prices.length; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
            }
            return dp[prices.length - 1][0];
        }
    }
}
```

### 买卖股票的最佳时机3_123

原始的状态转移方程:

```
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

这道题目和之前不同的点在于k, 前面的题目和k的关系并不大, 要么是k=1, 要么就是不限制交易次数, k无限大, 那么自然的对于k的遍历就省略了.

如果按照之前的思路写代码如下(错误!!!):

```java
int k = 2;
int[][][] dp = new int[n][k + 1][2];
for (int i = 0; i < n; i++) {
    if (i - 1 == -1) {
        // 处理 base case
        dp[i][k][0] = 0;
        dp[i][k][1] = -prices[i];
        continue;
    }
    dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
    dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
}
return dp[n - 1][k][0];
```

但是这样子是错误的, 虽然之前的题目是这个样子的, 但是之前的题目对于k的穷举被省略掉了, 但是这里明确了k=2, 无法消除k的影响, 所以就需要对k也遍历. *n × max_k × 2* 个状态

---

同时也可以倒过来遍历k

```java
// 原始版本
int maxProfit_k_2(int[] prices) {
    int max_k = 2, n = prices.length;
    int[][][] dp = new int[n][max_k + 1][2];
    for (int i = 0; i < n; i++) {
        for (int k = max_k; k >= 1; k--) {
            if (i - 1 == -1) {
                // 处理 base case
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[i];
                continue;
            }
            dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
        }
    }
    // 穷举了 n × max_k × 2 个状态，正确。
    return dp[n - 1][max_k][0];
}
```

但为什么我从大到小遍历 `k` 也可以正确提交呢？因为你注意看，`dp[i][k]` 不会依赖 `dp[i][k - 1]`，而是依赖 `dp[i - 1][k - 1]`，对于 `dp[i - 1][...]`，都是已经计算出来的。所以不管你是 `k = max_k, k--`，还是 `k = 1, k++`，都是可以得出正确答案的。

那为什么我使用 `k = max_k, k--` 的方式呢？因为这样符合语义。

你买股票，初始的「状态」是什么？应该是从第 0 天开始，而且还没有进行过买卖，所以最大交易次数限制 `k` 应该是 `max_k`；而随着「状态」的推移，你会进行交易，那么交易次数上限 `k` 应该不断减少，这样一想，`k = max_k, k--` 的方式是比较合乎实际场景的。

### 买卖股票的最佳时机4_188

最多可以完成k笔交易

有了上一题 `k = 2` 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 `k` 值会非常大，`dp` 数组太大了。现在想想，交易次数 `k` 最多有多大呢？

一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 `k` 应该不超过 `n/2`，如果超过，就没有约束作用了，相当于 `k = +infinity`。这种情况是之前解决过的。

















# subsequence






















# 其他

## 接雨水_42

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

### 直观的解法

就目测来看的解法的话, 就是遍历每一个柱子, 然后在这个柱子的左右两边最高柱子的高度的最小值 减去当前柱子本身的高度

也就是从左到右遍历height:

* 初始化leftMax=0, rightMax=0.
* 从[0, index]位置找当前位置左侧的最大值leftMax
* 从[index, length-1]位置找当前位置右侧的最大值rightMax
* result += min(leftMax, rightMax) - height[index]

代码:

```java
static class Solution {
    public int trap(int[] height) {
        int result = 0;

        for (int index = 0; index < height.length; index++) {
            int leftMax = 0;
            int rightMax = 0;

            // 左侧最大值
            for (int j = 0; j <= index; j++) {
                leftMax = Math.max(leftMax, height[j]);
            }

            // 右侧最大值
            for (int j = index; j <= height.length - 1; j++) {
                rightMax = Math.max(rightMax, height[j]);
            }

            result += Math.min(leftMax, rightMax) - height[index];
        }

        return result;
    }
}
```

### dp

直接解法的问题在于, 每次都要去找当前位置的最大最小值, 所以优化解法

提前存储每个位置上所有左边柱子高度的最大值和右边柱子高度的最大值

对于案例1中的数组: [0,1,0,2,1,0,1,3,2,1,2,1]

正向遍历数组, 得到每个位置左边柱子的高度最大值. 每个位置上从左往右看的最大值

left_max_array = [0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3]

反向遍历数组, 得到每个位置右边柱子的高度最大值. 每个位置上从右往左看的最大值

reverse_right_max_array = [1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3]

right_max_array = [3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1]

---

sum up:

height =          [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]

left_max_array =  [0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3]

right_max_array = [3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1]

求高度的逻辑是一样的, 左右的最小值减去当前的高度, 最后求和即可

offset =          [0, 0, 1, 0, 1, 2, 1, 0, 0, 1, 0, 0]

求和是6

### 单调栈



### 双指针









## 等差数列划分_413

给你一个整数数组 `nums` ，返回数组 `nums` 中所有为等差数组的 **子数组** 个数。

**子数组** 是数组中的一个连续序列。

至少要三个元素

### 直观

双for, 每一个位置和他之后的两个位置开始遍历, 看diff

```java
static class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        int length = nums.length;
        if (length < 3) {
            return 0;
        }
        int result = 0;
        for (int i = 0; i <= length - 3; i++) {
            int diff = nums[i + 1] - nums[i];
            for (int j = i + 2; j <= length - 1; j++) {
                if (nums[j] - nums[j - 1] == diff) {
                    result++;
                } else {
                    break;
                }
            }
        }
        return result;
    }
}
```

### dp

1. 状态dp[i]: 以nums[i]为结尾数字的等差数列, 对所有的dp[i]求和就是nums中所有的等差数列总个数

2. base case: 因为长度至少为3, 所以dp[0] = 0, dp[1] = 0

3. 转移方程

[1,2,3,4,5,7]. 以这个例子为参考









思路：

1. 定义状态 dp[i] : 以 nums[ i ] 结尾的等差子数列的个数， 对 dp[ i ] ( 0 <= i < n ) 求和 就得到 nums 中 等差数列的总的个数；
2. 状态初始化 ： 由于题目要求的等差数列长度不能小于3 ，dp[ 0 ] = 0, dp [ 1 ] = 0;
3. 状态转移方程 ： 举栗子 nums = [1,2,3,4,5,7 ] , dp[0] = 0, dp[1] = 0, 对 dp[2] , nums[2] - nums[1] == nums[1] - nums[0] , dp[2] = dp[1] + 1 = 0 + 1; dp[2] 相对于 dp[1] 多了一个以 nums[2] 结尾的 [1,2,3] 对 dp[3] , nums[3] - nums[2] ==nums[2] - nums[1] , dp[3] = dp[2] + 1 = 0 + 1; dp[3] 相对于 dp[2] 多了一个以 nums[] 结尾的 [2,3,4]; . . . 对 dp[5] , nums[5] - nums[4] != nums[4] - nums[3] , dp[5] = 0;

dp[i] = nums[i] - nums[i-1] == nums[i-1] - nums[i-2] ? dp[i-1] + 1 : 0;

因为 dp [i] 只和 dp[i-1] 有关， 所以使用一个变量记录状态转移就可以了。

```
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        const int n = nums.size();
        int dp = 0;
        int ans = 0;
        for(int i = 2; i < n; ++i){
            dp = nums[i] - nums[i-1] == nums[i-1] - nums[i-2] ? dp + 1 : 0;
            ans += dp;
        }
        return ans;
    }
};
```











































































