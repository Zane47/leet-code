# 爬楼梯 & FibonacciNumber
## FibonacciNumber_509 & ClimbingStairs_70
Fibonacci直接告诉递推公式: f(n) = f(n-1) + f(n-2)  

爬楼梯问题也是类似的, 因为每次都可以爬两个台阶或者一个台阶

```
dp, 每次你可以爬 1 或 2 个台阶
dp[n]有多少中爬法
dp[n]就是dp[n-1]爬一个台阶, dp[n-2]爬两个台阶, 这两个爬法加起来
f(n) = f(n-1) + f(n-2)
```

```java
public int climbStairs(int n) {
    int[] step = new int[1000];
    step[0] = 0;
    step[1] = 1;
    step[2] = 2;
    for (int i = 3; i <= n; i++) {

        step[i] = step[i - 1] + step[i - 2];

    }
    return step[n];
}
```

实际上发现, 他只与前两次状态有关, pre1, pre2, cur. 降低空间复杂度

```java
public int climbStairs(int n) {
    if (n == 0 || n == 1 || n == 2) {
        return n;
    }
    int result = 0;
    int pre1 = 1;
    int pre2 = 2;
    for (int i = 3; i <= n; i++) {
        result = pre1 + pre2;
        pre1 = pre2;
        pre2 = result;
    }
    return result;
}
```



## NthTribonacciNumber_1137

```
Tn+3 = Tn + Tn+1 + Tn+2
```

类似普通的Fibonacci, 无非就是每一个dp状态与前三个数字有关

```java
public int tribonacci(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    if (n == 2) {
        return 1;
    }

    int result = 0;
    int pre1 = 0;
    int pre2 = 1;
    int pre3 = 1;

    for (int i = 3; i <= n; i++) {
        result = pre1 + pre2 + pre3;
        pre1 = pre2;
        pre2 = pre3;
        pre3 = result;
    }

    return result;
}
```









## 最小花费爬楼梯:MinCostClimbingStairs_746

```
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。
一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费。
```

```
dp[i]: 爬到第i个台阶的最小花费
dp[i]有两种可能:
1. 第i-1号台阶, 支付了cost[i-1]然后爬1步上来的
2. 第i-2号台阶, 支付了cost[i-2]然后爬2步上来的
看哪个花费最小.Math.min()
n=3, 那么就要爬到第3号台阶, 0,1,2,3
```

```java
public int minCostClimbingStairs(int[] cost) {
    int n = cost.length;
    if (n == 0) {
        return 0;
    }
    // 可以从0号台阶, 或者1号台阶开始爬, 那么就不需要任何花费
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 0;
    for (int i = 2; i <= n; i++) {
        dp[i] = Math.min(
            dp[i - 1] + cost[i - 1],
            dp[i - 2] + cost[i - 2]);
    }
    return dp[n];
}
```











# 打家劫舍问题
## HouseRobber1_198

```java
/**
     * dp[i]: 偷到第i家的时候, 能偷到的最多的前
     * dp[0]: 第0家, 那么必偷
     * dp[1]: 就看偷不偷0, 如果偷0, 那么1就不偷, 如果不偷0, 就偷1
     * 所以要看dp[0]和nums[1]的大小
     * <p>
     * 所以dp[i]取决于dp[i-1], 偷不偷第i-1户人家,
     * 如果偷i-1th: 那就偷不了nums[i], 钱就是dp[i-1]
     * 如果不偷i-1th: 那就要偷nums[i], 钱就是dp[i-2] + nums[i]
     * 看哪个大
     */
static class Solution {
    public int rob(int[] nums) {
        int n = nums.length;

        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }

        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }
}
```

## HouseRobber2_213

和1的不同点在于是环, 意味着

1. 如果你选择了第一个房屋偷窃，就一定不能选择最后一间了

2. 如果你没有选择第一个房屋偷窃，那么你就能偷窃最后一间房屋。

所以这里转换成两个区间[0, n-2]和[1, n-1], 分别是rob1的思路, 然后取大的那个

```java
/**
     * 成了一个环, 那么如果投了第n-1个, 就不能偷第0个
     * 如果没有偷第0个就可以偷第n-1个
     * <p>
     * 所以这里可以把理解成, 我偷两次, 只不过范围不一样, 然后投的策略和1是一样的
     * <p>
     * 例如: 6户人家, 两种偷法 , 取最大的那个
     * 0 1 2 3 4 5
     * 0 1 2 3 4
     * 1 2 3 4 5
     */
static class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }
        if (n == 2) {
            return Math.max(nums[0], nums[1]);
        }

        int[] path1 = new int[n - 1];
        System.arraycopy(nums, 0, path1, 0, n - 1);

        int[] path2 = new int[n - 1];
        System.arraycopy(nums, 1, path2, 0, n - 1);

        return Math.max(rob1(path1), rob1(path2));
    }

    private int rob1(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(
                dp[i - 1],
                dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }
}
```

## DeleteAndEarn_740

这道题目其实就是打家劫舍, 自己想的时候咩有关联起来

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除**所有**等于 nums[i] - 1 和 nums[i] + 1 的元素。

重点在于上面说的"所有", 所以例子:[2,2,3,3,3,4]:

选3, 删除所有的2(有两个), 删除4. nums=[3,3]

选3, 没有好删除的数字, nums=[3]

选3.

最后result就是3+3+3 = 9;

---

所以数组nums = [2,2,3,3,3,4]可以转换为打家劫舍的形式:

每个位置都是对应的数字个数, 也就是资产, 

count=[0, 0, 2, 3, 1]. 0个0, 0个1, 2个2, 3个3, 1个4

count数组记录, nums数组中数字出现的个数

count[m] = n, 数字m出现了n次

---

状态方程的思考过程: 

dp[i]: 到了第i个位置上, result的最大值, (到第i个位置, 删除数字的和最大)

第i个位置的数字可以删除也可以不删除, 依据是: 两种前结果之上进行选择的：

1. 如果你不删除当前位置的数字，那么你得到就是前一个数字的位置的最优结果。
2. 如果你觉得当前的位置数字i需要被删，那么你就会得到i - 2位置的那个最优结果加上当前位置的数字乘以个数。

dp[i] = max(dp[i-1], dp[i-2] + count[i] * i)

---

初始化

i-2, 所以初始化0,1
dp[0] : 0乘以任何数都是0, 初始化就是0
dp[1] = count[1] * 1;

---

最终

```java
/**
     * ount=[0, 0, 2, 3, 1]. 0个0, 0个1, 2个2, 3个3, 1个4
     * <p>
     * 状态方程的思考过程:
     * <p>
     * dp[i]: 到了第i个位置上, result的最大值, (到第i个位置, 删除数字的和最大)
     * <p>
     * 第i个位置的数字可以删除也可以不删除, 依据是: 两种前结果之上进行选择的：
     * <p>
     * 1. 如果你不删除当前位置的数字，那么你得到就是前一个数字的位置的最优结果。
     * 2. 如果你觉得当前的位置数字i需要被删，那么你就会得到i - 2位置的那个最优结果加上当前位置的数字乘以个数。
     * <p>
     * dp[i] = max(dp[i-1], dp[i-2] + count[i] * i)
     */
static class Solution {
    public int deleteAndEarn(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        int max = -1;
        for (int num : nums) {
            if (num > max) {
                max = num;
            }
        }

        // 数字出现的次数
        // count[m] = n, 数字m出现了n次
        int[] count = new int[max + 1];

        // count数组记录, nums数组中数字出现的个数
        for (int num : nums) {
            count[num]++;
        }

        // dp: 到数字i, result的最大值, 看数字i取不取, 取与不取有两种情况
        int[] dp = new int[max + 1];
        // 数字0, 没用
        dp[0] = 0;
        dp[1] = count[1] * 1;
        for (int i = 2; i <= max; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + count[i] * i);
        }
        return dp[max];
    }
}
```









## HouseRobber3_337










# 背包问题











# 股票售卖最佳时机
121, 122, 123, 188, 309, 714









# subsequence










# 其他









