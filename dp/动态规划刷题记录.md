# 爬楼梯 & FibonacciNumber
## FibonacciNumber_509 & ClimbingStairs_70
Fibonacci直接告诉递推公式: f(n) = f(n-1) + f(n-2)  

爬楼梯问题也是类似的, 因为每次都可以爬两个台阶或者一个台阶

```
dp, 每次你可以爬 1 或 2 个台阶
dp[n]有多少中爬法
dp[n]就是dp[n-1]爬一个台阶, dp[n-2]爬两个台阶, 这两个爬法加起来
f(n) = f(n-1) + f(n-2)
```

```java
public int climbStairs(int n) {
    int[] step = new int[1000];
    step[0] = 0;
    step[1] = 1;
    step[2] = 2;
    for (int i = 3; i <= n; i++) {

        step[i] = step[i - 1] + step[i - 2];

    }
    return step[n];
}
```

实际上发现, 他只与前两次状态有关, pre1, pre2, cur. 降低空间复杂度

```java
public int climbStairs(int n) {
    if (n == 0 || n == 1 || n == 2) {
        return n;
    }
    int result = 0;
    int pre1 = 1;
    int pre2 = 2;
    for (int i = 3; i <= n; i++) {
        result = pre1 + pre2;
        pre1 = pre2;
        pre2 = result;
    }
    return result;
}
```



## NthTribonacciNumber_1137

```
Tn+3 = Tn + Tn+1 + Tn+2
```

类似普通的Fibonacci, 无非就是每一个dp状态与前三个数字有关

```java
public int tribonacci(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    if (n == 2) {
        return 1;
    }

    int result = 0;
    int pre1 = 0;
    int pre2 = 1;
    int pre3 = 1;

    for (int i = 3; i <= n; i++) {
        result = pre1 + pre2 + pre3;
        pre1 = pre2;
        pre2 = pre3;
        pre3 = result;
    }

    return result;
}
```









## 最小花费爬楼梯:MinCostClimbingStairs_746

```
给你一个整数数组 cost ,其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用.
一旦你支付此费用,即可选择向上爬一个或者两个台阶.
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯.
请你计算并返回达到楼梯顶部的最低花费.
```

```
dp[i]: 爬到第i个台阶的最小花费
dp[i]有两种可能:
1. 第i-1号台阶, 支付了cost[i-1]然后爬1步上来的
2. 第i-2号台阶, 支付了cost[i-2]然后爬2步上来的
看哪个花费最小.Math.min()
n=3, 那么就要爬到第3号台阶, 0,1,2,3
```

```java
public int minCostClimbingStairs(int[] cost) {
    int n = cost.length;
    if (n == 0) {
        return 0;
    }
    // 可以从0号台阶, 或者1号台阶开始爬, 那么就不需要任何花费
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 0;
    for (int i = 2; i <= n; i++) {
        dp[i] = Math.min(
            dp[i - 1] + cost[i - 1],
            dp[i - 2] + cost[i - 2]);
    }
    return dp[n];
}
```











# 打家劫舍问题
## HouseRobber1_198

```java
/**
     * dp[i]: 偷到第i家的时候, 能偷到的最多的前
     * dp[0]: 第0家, 那么必偷
     * dp[1]: 就看偷不偷0, 如果偷0, 那么1就不偷, 如果不偷0, 就偷1
     * 所以要看dp[0]和nums[1]的大小
     * <p>
     * 所以dp[i]取决于dp[i-1], 偷不偷第i-1户人家,
     * 如果偷i-1th: 那就偷不了nums[i], 钱就是dp[i-1]
     * 如果不偷i-1th: 那就要偷nums[i], 钱就是dp[i-2] + nums[i]
     * 看哪个大
     */
static class Solution {
    public int rob(int[] nums) {
        int n = nums.length;

        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }

        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }
}
```

## HouseRobber2_213

和1的不同点在于是环, 意味着

1. 如果你选择了第一个房屋偷窃,就一定不能选择最后一间了

2. 如果你没有选择第一个房屋偷窃,那么你就能偷窃最后一间房屋.

所以这里转换成两个区间[0, n-2]和[1, n-1], 分别是rob1的思路, 然后取大的那个

```java
/**
     * 成了一个环, 那么如果投了第n-1个, 就不能偷第0个
     * 如果没有偷第0个就可以偷第n-1个
     * <p>
     * 所以这里可以把理解成, 我偷两次, 只不过范围不一样, 然后投的策略和1是一样的
     * <p>
     * 例如: 6户人家, 两种偷法 , 取最大的那个
     * 0 1 2 3 4 5
     * 0 1 2 3 4
     * 1 2 3 4 5
     */
static class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }
        if (n == 2) {
            return Math.max(nums[0], nums[1]);
        }

        int[] path1 = new int[n - 1];
        System.arraycopy(nums, 0, path1, 0, n - 1);

        int[] path2 = new int[n - 1];
        System.arraycopy(nums, 1, path2, 0, n - 1);

        return Math.max(rob1(path1), rob1(path2));
    }

    private int rob1(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(
                dp[i - 1],
                dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }
}
```

## DeleteAndEarn_740

这道题目其实就是打家劫舍, 自己想的时候咩有关联起来

每次操作中,选择任意一个 nums[i] ,删除它并获得 nums[i] 的点数.之后,你必须删除**所有**等于 nums[i] - 1 和 nums[i] + 1 的元素.

重点在于上面说的"所有", 所以例子:[2,2,3,3,3,4]:

选3, 删除所有的2(有两个), 删除4. nums=[3,3]

选3, 没有好删除的数字, nums=[3]

选3.

最后result就是3+3+3 = 9;

---

所以数组nums = [2,2,3,3,3,4]可以转换为打家劫舍的形式:

每个位置都是对应的数字个数, 也就是资产, 

count=[0, 0, 2, 3, 1]. 0个0, 0个1, 2个2, 3个3, 1个4

count数组记录, nums数组中数字出现的个数

count[m] = n, 数字m出现了n次

---

状态方程的思考过程: 

dp[i]: 到了第i个位置上, result的最大值, (到第i个位置, 删除数字的和最大)

第i个位置的数字可以删除也可以不删除, 依据是: 两种前结果之上进行选择的:

1. 如果你不删除当前位置的数字,那么你得到就是前一个数字的位置的最优结果.
2. 如果你觉得当前的位置数字i需要被删,那么你就会得到i - 2位置的那个最优结果加上当前位置的数字乘以个数.

dp[i] = max(dp[i-1], dp[i-2] + count[i] * i)

---

初始化

i-2, 所以初始化0,1
dp[0] : 0乘以任何数都是0, 初始化就是0
dp[1] = count[1] * 1;

---

最终

```java
/**
     * ount=[0, 0, 2, 3, 1]. 0个0, 0个1, 2个2, 3个3, 1个4
     * <p>
     * 状态方程的思考过程:
     * <p>
     * dp[i]: 到了第i个位置上, result的最大值, (到第i个位置, 删除数字的和最大)
     * <p>
     * 第i个位置的数字可以删除也可以不删除, 依据是: 两种前结果之上进行选择的:
     * <p>
     * 1. 如果你不删除当前位置的数字,那么你得到就是前一个数字的位置的最优结果.
     * 2. 如果你觉得当前的位置数字i需要被删,那么你就会得到i - 2位置的那个最优结果加上当前位置的数字乘以个数.
     * <p>
     * dp[i] = max(dp[i-1], dp[i-2] + count[i] * i)
     */
static class Solution {
    public int deleteAndEarn(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        int max = -1;
        for (int num : nums) {
            if (num > max) {
                max = num;
            }
        }

        // 数字出现的次数
        // count[m] = n, 数字m出现了n次
        int[] count = new int[max + 1];

        // count数组记录, nums数组中数字出现的个数
        for (int num : nums) {
            count[num]++;
        }

        // dp: 到数字i, result的最大值, 看数字i取不取, 取与不取有两种情况
        int[] dp = new int[max + 1];
        // 数字0, 没用
        dp[0] = 0;
        dp[1] = count[1] * 1;
        for (int i = 2; i <= max; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + count[i] * i);
        }
        return dp[max];
    }
}
```









## HouseRobber3_337










# 背包问题











# 股票售卖最佳时机
121, 122, 123, 188, 309, 714

## 通用题解

[通用题解1](https://labuladong.gitee.io/algo/3/26/95/)

[通用题解2](https://leetcode-cn.com/circle/article/qiAgHn/)

### 穷举框架

**每天都有三种「选择」**:买入、卖出、无操作,我们用 `buy`, `sell`, `rest` 表示这三种选择.

但问题是,并不是每天都可以任意选择这三种选择的,因为 `sell` 必须在 `buy` 之后,`buy` 必须在 `sell` 之后.那么 `rest` 操作还应该分两种状态,一种是 `buy` 之后的 `rest`（持有了股票）,一种是 `sell` 之后的 `rest`（没有持有股票）.而且别忘了,我们还有交易次数 `k` 的限制,就是说你 `buy` 还只能在 `k > 0` 的前提下操作.

```
dp[i][k][0 or 1]
0 <= i <= n - 1, 1 <= k <= K
n 为天数,大 K 为交易数的上限,0 和 1 代表是否持有股票.
for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
```

而且我们可以用自然语言描述出每一个状态的含义,比如说 `dp[3][2][1]` 的含义就是:今天是第三天,我现在手上持有着股票,至今最多进行 2 次交易.再比如 `dp[2][3][0]` 的含义:今天是第二天,我现在手上没有持有股票,至今最多进行 3 次交易.

我们想求的最终答案是 `dp[n - 1][K][0]`,即最后一天,最多允许 `K` 次交易,最多获得多少利润.

为什么不是 `dp[n - 1][K][1]`？因为 `dp[n - 1][K][1]` 代表到最后一天手上还持有股票,`dp[n - 1][K][0]` 表示最后一天手上的股票已经卖出去了,很显然后者得到的利润一定大于前者

### 状态转移

```
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max( 今天选择 rest,        今天选择 sell       )
```

解释: 今天我没有持有股票, 从昨天推过来有两种可能, 取最大值

1. 我昨天就没有持有, 且截至昨天最大交易次数限制为 `k`; 然后我今天选择 `rest`, 所以我今天还是没有持有, 最大交易次数限制依然为 `k`.

2. 我昨天持有股票, 且截至昨天最大交易次数限制为 `k`; 但是今天我 `sell` 了, 所以我今天没有持有股票了, 最大交易次数限制依然为 `k`.

---

```
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max( 今天选择 rest,         今天选择 buy         )
```

1. 我昨天就持有着股票, 且截至昨天最大交易次数限制为 `k`; 然后今天选择 `rest`, 所以我今天还持有着股票, 最大交易次数限制依然为 `k`. 

2. 我昨天本没有持有, 且截至昨天最大交易次数限制为 `k - 1`; 但今天我选择 `buy`, 所以今天我就持有股票了, 最大交易次数限制为 `k`. 

> 这里着重提醒一下，时刻牢记「状态」的定义，`k` 的定义并不是「已进行的交易次数」，而是「最大交易次数的上限限制」。如果确定今天进行一次交易，且要保证截至今天最大交易次数上限为 `k`，那么昨天的最大交易次数上限必须是 `k - 1`。

如果 `buy`，就要从利润中减去 `prices[i]`，如果 `sell`，就要给利润增加 `prices[i]`。今天的最大利润就是这两种可能选择中较大的那个。

注意 `k` 的限制，在选择 `buy` 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 `k` 应该减小 1。

> 修正：以前我以为在 `sell` 的时候给 `k` 减小 1 和在 `buy` 的时候给 `k` 减小 1 是等效的，但细心的读者向我提出质疑，经过深入思考我发现前者确实是错误的，因为交易是从 `buy` 开始，如果 `buy` 的选择不改变交易次数 `k` 的约束，会出现交易次数超出限制的的错误。

###  base case

```
dp[-1][...][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。

dp[-1][...][1] = -infinity
解释：还没开始的时候，是不可能持有股票的。
因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。

dp[...][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。

dp[...][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的。
因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
```

---

总结: 

```
base case：
dp[-1][...][0] = dp[...][0][0] = 0
dp[-1][...][1] = dp[...][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

## 题目与解法

### 买卖股票的最佳时机_121

只交易一次, 所以k=1. 对上面的式子做一些调整:

```
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) 
            = max(dp[i-1][1][1], -prices[i])
解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。

现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
可以进行进一步化简去掉所有 k：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
```

i=0的时候, base case

```
dp[i][0] = 0;
// 根据状态转移方程可得：
//   dp[i][0] 
// = max(dp[-1][0], dp[-1][1] + prices[i])
// = max(0, -infinity + prices[i]) = 0

dp[i][1] = -prices[i];
// 根据状态转移方程可得：
//   dp[i][1] 
// = max(dp[-1][1], dp[-1][0] - prices[i])
// = max(-infinity, 0 - prices[i]) 
// = -prices[i]
```

同时可以注意到, 这里状态只与之前的i-1的状态有关, 所以实际上不需要用一整个数组来进行存储, 可以只使用两个数字来记录前两个状态. 解法如下:

```java
public class BuyAndSellStock_121_2 {
    public static void main(String[] args) {
        int[] prices = {7, 1, 5, 3, 6, 4};
        System.out.println(new Solution().maxProfit(prices));

    }
    /**
     * solution2中可以看到状态只与前一天有关, 所以不需要数组, 只需要保存前一天数据即可
     *
     * # 三维
     * dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]);
     * dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]);
     *             = max(dp[i-1][1][1], -prices[i]);
     *
     * # 二维
     * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
     * dp[i][1] = max(dp[i-1][1], -prices[i]);
     *
     * dp[0][0] = 0
     * dp[0][1] = -prices[i];
     *
     * # 只与前一个状态有关
     */
    static class Solution {
        public int maxProfit(int[] prices) {
            int n = prices.length;
            int dp_pre_0 = 0;
            int dp_pre_1 = -prices[0];

            int dp_cur_0 = 0;
            int dp_cur_1 = 0;

            for (int i = 1; i < n; i++) {
                dp_cur_0 = Math.max(dp_pre_0, dp_pre_1 + prices[i]);
                dp_cur_1 = Math.max(dp_pre_1, -prices[i]);

                dp_pre_0 = dp_cur_0;
                dp_pre_1 = dp_cur_1;
            }

            return dp_cur_0;
        }
    }

    /**
     * 按照笔记中的通用方法
     * <p>
     * dp[i][k][0 or 1]: 第i天, 最多交易次数为k,0: 没有持有股票, 1: 持有股票.
     * 最多获得多少利润。
     * <p>
     * 这里的因为只bug sell一次, 所以k = 1
     * 务必在buy的时候, k--;
     * <p>
     * # 状态转移:
     * 今天未持有股票:
     * dp[i][1][0]: max(dp[i-1][1][0], dp[i-1][1][1] + price[i])
     * 1. 昨天未持有股票, 今天啥都没干. rest
     * 2. 昨天持有股票, 今天卖了股票. sell
     * <p>
     * 今天持有股票:
     * dp[i][1][1]: max(dp[i-1][1][1], dp[i-1][0][0] - price[i])
     * 因为dp[i-1][0][0]: 最大交易次数为0, 并且不持有股票, 所以 = 0
     * dp[i][1][1] = max(dp[i-1][1][1], -price[i])
     * <p>
     * 1. 昨天也持有股票, 今天rest
     * 2. 昨天未持有股票, 今天buy
     * <p>
     * <p>
     * dp[i][1][0]: max(dp[i-1][1][0], dp[i-1][1][0] + price[i])
     * dp[i][1][1] = max(dp[i-1][1][1], -price[i])
     * 因为这里的k的次数固定是1, 所以这一维的状态可以不用管. 3维 -> 2维
     * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + price[i])
     * dp[i][1] = max(dp[i-1][1], -price[i])
     * <p>
     * <p>
     * # base case:
     * i-1, 所以i=0的情况
     * dp[0][0] = max(dp[-1][0], dp[-1][1] + price[0])
     * = max(0, -inf) = 0
     * 因为dp[-1][1], 在-1天的时候不可能持有股票
     * <p>
     * <p>
     * dp[0][1] = max(dp[-1][1], -price[0])
     * = -price[0]
     */
    static class Solution2 {
        public int maxProfit(int[] prices) {
            int n = prices.length;
            int[][] dp = new int[n][2];
            dp[0][0] = 0;
            dp[0][1] = -prices[0];

            for (int i = 1; i < n; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
            }

            return dp[n - 1][0];
        }
    }
    /**
     * 暴力, 超时
     * 找出数组中两个数字之间的最大差值
     * 双for
     */
    static class Solution1 {
        public int maxProfit(int[] prices) {
            int max = 0;

            for (int i = 0; i < prices.length; i++) {
                for (int j = i + 1; j < prices.length; j++) {
                    int profit = prices[j] - prices[i];
                    if (profit > max) {
                        max = profit;
                    }
                }
            }
            return max;
        }
    }
}
```

### 买卖股票的最佳时机2_122

你可以尽可能地完成更多的交易(多次买卖一支股票), 所以k是+inf, 所以k和k-1就一样了

状态转移方程:

```
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]);
```

也就是说, 和k无关了, 所以取消k的维度

```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
```

base case:

```
dp[0][0] = max(dp[-1][0], dp[-1][1] + prices[0]) = 0
dp[0][1] = max(dp[-1][1], dp[-1][0] - prices[0]) = -prices[0]
```

同时和1一样观察看实际只与前一天的状态有关, 不需要用数组存储

```java
public class BuyAndSellStock2_122 {
    public static void main(String[] args) {
        int[] prices = {7, 1, 5, 3, 6, 4};
        System.out.println(new Solution().maxProfit(prices));
    }
    static class Solution {
        public int maxProfit(int[] prices) {
            int n = prices.length;

            // base case:
            int dp_pre_0 = 0;
            int dp_pre_1 = -prices[0];

            int dp_cur_0 = 0;
            int dp_cur_1 = 0;

            for (int i = 1; i < n; i++) {
                dp_cur_0 = Math.max(dp_pre_0, dp_pre_1 + prices[i]);
                dp_cur_1 = Math.max(dp_pre_1, dp_pre_0 - prices[i]);

                dp_pre_0 = dp_cur_0;
                dp_pre_1 = dp_cur_1;
            }

            return dp_cur_0;
        }
    }
    /**
     * 你可以尽可能地完成更多的交易(多次买卖一支股票), 所以k是+inf, 所以k和k-1就一样了
     * <p>
     * 状态转移方程:
     * dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
     * dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
     * = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]);
     * <p>
     * 也就是说, 和k无关了, 所以取消k的维度
     * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
     * dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
     * <p>
     * <p>
     * base case:
     * dp[0][0] = max(dp[-1][0], dp[-1][1] + prices[0]) = 0
     * <p>
     * dp[0][1] = max(dp[-1][1], dp[-1][0] - prices[0]) = -prices[0]
     */
    static class Solution1 {
        public int maxProfit(int[] prices) {
            int n = prices.length;

            int[][] dp = new int[n][2];
            dp[0][0] = 0;
            dp[0][1] = -prices[0];

            for (int i = 1; i < n; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            }
            return dp[n - 1][0];
        }
    }
}
```

### 买卖股票的最佳时机含手续费_714

你可以无限次地完成交易, 但是你每笔交易都需要付手续费

k=inf, 交易的时候减去fee -> buy的时候-fee和sell的时候-fee

具体的推导见代码注释:

```java
/**
 * 对股票买卖2的扩展
 * 无限次地完成交易, 但是你每笔交易都需要付手续费
 * k=inf, 交易加上fee
 */
public class BuyAndSellStockWithTransactionFee_714 {
    public static void main(String[] args) {

        int[] prices = new int[]{1, 3, 2, 8, 4, 9};
        int fee = 2;
        System.out.println(new Solution().maxProfit(prices, fee));

    }
    /**
     * # 状态转移1
     * ## buy的时候交手续费
     * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
     * dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
     * <p>
     * ## sell时缴费的base case
     * dp[0][0] = max(dp[-1][0], dp[-1][1] + prices[0])
     * = max(0, -inf) = 0
     * <p>
     * dp[0][1] = max(dp[-1][1], dp[-1][0] - prices[0] - fee)
     * = max(-inf, -price[0] - fee) = -price[0] - fee
     */
    static class Solution {
        public int maxProfit(int[] prices, int fee) {
            int[][] dp = new int[prices.length][2];

            dp[0][0] = 0;
            dp[0][1] = -prices[0] - fee;

            for (int i = 1; i < prices.length; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
            }

            return dp[prices.length - 1][0];
        }
    }

    /**
     * sell的时候交手续费
     * dp[i][k][0]
     * <p>
     * dp[i][k][1]
     * <p>
     * <p>
     * 因为有手续费, 所以在sell或者buy的时候减去手续费
     * k是inf, 不再考虑
     * <p>
     * # 状态转移1
     * ## sell的时候交手续费
     * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)
     * dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
     * <p>
     * ## sell时缴费的base case
     * dp[0][0] = max(dp[-1][0], dp[-1][1] + prices[0] - fee)
     * = max(0, -inf) = 0
     * <p>
     * dp[0][1] = max(dp[-1][1], dp[-1][0] - prices[0])
     * = max(-inf, -price[0]) = -price[0]
     */
    static class Solution1 {
        public int maxProfit(int[] prices, int fee) {
            int[][] dp = new int[prices.length][2];

            dp[0][0] = 0;
            dp[0][1] = -prices[0];

            for (int i = 1; i < prices.length; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            }
            return dp[prices.length - 1][0];
        }
    }

}
```

> (虽然没有遇到): 
>
> 如果直接把 `fee` 放在第一个式子里减，会有测试用例无法通过，错误原因是整型溢出而不是思路问题。一种解决方案是把代码中的 `int` 类型都改成 `long` 类型，避免 `int` 的整型溢出。

### 最佳买卖股票时机含冷冻期_309













# subsequence










# 其他









